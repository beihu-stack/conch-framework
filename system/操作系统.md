## 操作系统

<img src="../netty/assets/操作系统架构.jpg" alt="操作系统架构" style="zoom: 50%;" />



### 内存分配

##### 虚拟地址

每个应用程序的**虚拟地址空间**是相同的，但是互相独立

创建：链接器，程序编译后，需链接成可执行文件，链接器将多个代码模块组装在一起，并解决模块间的引用，即处理程序代码间的地址引用，形成程序运行的静态内存空间视图



##### 物理地址

内存只认识 物理地址（逻辑上也是一个数据，这个数据会被地址译码器等电子器件变成电子信号，放到地址总线上，地址总线电子信号的各种组合就可以选择到内存的储存单元了）



##### 虚拟地址 转换成 物理地址

**MMU（内存管理单元）**：可以接受软件给出的地址对应关系数据，进行地址转换

<img src="assets/image-20211030222349680.png" alt="image-20211030222349680" style="zoom:40%;" />

**地址转换表（页表）**：存储在物理内存中！

**分页模型**：

虚拟地址和物理地址都分成同等大小的块，或者叫页，按照虚拟页和物理页进行转换

<img src="assets/image-20211030222801857.png" alt="image-20211030222801857" style="zoom:50%;" />



##### MMU（内存管理单元）

页表中不存储虚拟地址与物理地址的对应关系（为了增加灵活性，节约物理内存），只存储 物理页面的地址。

MMU以虚拟地址为索引去查询表返回物理页面地址。

页表是分级的：

- 顶级页目录
- 中级页目录
- 页表

逻辑图：（每种模式下的分页具体实现不一样）

<img src="assets/image-20211031192538383.png" alt="image-20211031192538383" style="zoom:50%;" />

一个虚拟地址被分为 **四个段**



##### 内存控制器

集成在北桥中，现代系统主板将北桥集成到了CPU芯片中，可大大提升CPU访问内存的性能



##### Cache（硬件支持：高速存储器）

程序具有局部性原理，即CPU大多数时间在访问相同或者相邻的地址，所以在内存与CPU之间设计一个小而快的高速缓存

Cache也集成在CPU内部

Cache组成：

- 高速的静态存储器
  - Cache将高速静态存储器和内存分成大小相同的行，每行大小通常为32字节或者64字节，Cache和内存交换的最小单位就是一行，为方便管理，Cache内部多个行又会形成一组
- 地址转换模块
  - 接收CPU发出的地址，将地址分成3段：组号、行号、行内偏移
- Cache行替换模块
  - 脏位、回写位、访问位

Cache工作流程：

- CPU发出地址，由地址转换器转换
- Cache依据地址转换器的转换后的 组号、行号，定位到高速静态存储器的对应行
  - 如果命中，则使用行内偏移读取并返回数据给CPU
  - 未命中，则分配一个新行并访问内存，把内存中的对应的数据加载到Cache中并返回给CPU
    - 如果没有新行了，则进行行替换逻辑，找出一个Cache行，将其回写内存，腾出空间
  - 写入操作（内存）：
    - 回写：写入对应Cache行就结束了
    - 直写：写入Cache行的同时写入内存

Cache数据一致性问题：

- 三级缓存的CPU：
  - 一级Cache是指令和数据分开的，CPU核心互相独立
    - 一个CPU核心中的指令和数据Cache的一致性
  - 二级Cache对CPU核心互相独立
    - 多个CPU核心各自二级Cache的一致性的问题
  - 三级Cache所有CPU核心共享
    - 三级缓存对应CPU维度来说没有一致性问题，但是三级缓存 与 设备内存，如 DMA、网卡帧存储、显存之间存在一致性问题

- 解决：Cache数据同步协议（MESI、MOESI）
  - MESI（Modified修改、Exclusive独占、Shared共享、Invalid无效）：定义了四种状态
- 解决并发数据同步问题
  - 原子变量
    - Linux提供一个原子类型变量 atomic_t，需使用Linux提供的函数去操作使用
  - 控制中断
    - 关闭中断，防止因多个中断引起的对共享数据访问问题（如设备驱动程序在设置设备寄存器时，需要让CPU停止响应中断）
  - 多核CPU，使用自旋锁 协调多个CPU核心
    - **自旋锁** 的实现由有系统硬件提供的，CPU会给我提供一个原子交换指令（x86系统CPU：xchg指令）：他可以让寄存器里面的一个值与内存空间中的一个之值进行交换，并且不受CPU干扰
      - 中断关闭下，获取自旋锁，恢复中断，则释放自旋锁
  - 使用信号量
    - 自旋锁 不适合长时间等待的情况
  - 读写锁
    - Linux 读写锁的原理本质是基于计数器，初始值为 0x01000000，获取读锁时对其减 1，结果不小于 0 则表示获取读锁成功，获取写锁时直接减去 0x01000000。
      1. 获取读锁时，锁值变量 lock 计数减去 1，判断结果的符号位是否为 1。若结果符号位为 0 时，获取读锁成功，即表示 lock 大于 0。
      2. 获取读锁时，锁值变量 lock 计数减去 1，判断结果的符号位是否为 1。若结果符号位为 1 时，获取读锁失败，表示此时读写锁被修改数据的进程占有，此时调用 __read_lock_failed 失败处理函数，循环测试 lock+1 的值，直到结果的值大于等于 1。
      3. 获取写锁时，锁值变量 lock 计数减去 RW_LOCK_BIAS_STR，即 lock-0x01000000，判断结果是否为 0。若结果为 0 时，表示获取写锁成功。
      4. 获取写锁时，锁值变量 lock 计数减去 RW_LOCK_BIAS_STR，即 lock-0x01000000，判断结果是否为 0。若结果不为 0 时，获取写锁失败，表示此时有读取数据的进程占有读锁或有修改数据的进程占有写锁，此时调用 __write_lock_failed 失败处理函数，循环测试 lock+0x01000000，直到结果的值等于 0x01000000。