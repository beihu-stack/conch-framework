## 高性能网络

### 操作系统架构

<img src="assets/操作系统架构.jpeg" alt="操作系统架构" style="zoom: 70%;" />

HAL层：硬件抽象层



### I/O模型

对于一个网络I/O通信过程，比如网络数据读取，会涉及两个对象，一个是调用这个I/O操作的用户线程，另外一个就是操作系统内核。一个进程的地址空间分为用户空间和内核空间，用户线程不能直接访问内核空间

当用户线程发起I/O操作后，网络数据读取操作会经历两个步骤：

- **用户线程等待内核将数据从网卡拷贝到内核空间**
- **内核将数据从内核空间拷贝到用户空间**

各种I/O模型的区别就是：它们实现这两个步骤的方式是不一样的

##### 同步阻塞I/O

用户线程发起read调用后就阻塞了，让出CPU。内核等待网卡数据到来，把数据从网卡拷贝到内核空间，接着把数据拷贝到用户空间，再把用户线程叫醒

<img src="assets/image-20210916173613966.png" alt="image-20210916173613966" style="zoom: 50%;" />



##### 同步非阻塞I/O

用户线程不断的发起read调用，数据没到内核空间时，每次都返回失败，直到数据到了内核空间，这一次read调用后，在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的，等数据到了用户空间再把线程叫醒

<img src="assets/image-20210916195133503.png" alt="image-20210916195133503" style="zoom:50%;" />



##### I/O多路复用

用户线程的读取操作分成两步了，线程先发起select调用，目的是问内核数据准备好了吗？等内核把数据准备好了，用户线程再发起read调用。在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的。那为什么叫I/O多路复用呢？**因为一次select调用可以向内核查多个数据通道（Channel）的状态**，所以叫多路复用。

<img src="assets/image-20210916203508876.png" alt="image-20210916203508876" style="zoom:50%;" />



##### 异步I/O

用户线程发起read调用的同时**注册一个回调函数**，read立即返回，等内核将数据准备好后，再调用指定的回调函数完成处理。在这个过程中，用户线程一直没有阻塞

<img src="assets/image-20210916215311887.png" alt="image-20210916215311887" style="zoom:50%;" />







### Reactor模型和Proactor模型

在高性能的I/O设计中，有两个著名的模型：Reactor模型和Proactor模型，其中**Reactor模型用于同步I/O**，而**Proactor模型运用于异步I/O操作**。

无论是Reactor模型还是Proactor模型，对于支持多连接的服务器，一般可以总结为2种fd和3种事件

![高性能I_O设计](assets/高性能I_O设计.png)

##### 2种fd

1. listenfd：一般情况，只有一个。用来监听一个特定的端口(如80)。
2. connfd：每个连接都有一个connfd。用来收发数据。

##### 3种事件

1. listenfd进行accept阻塞监听，创建一个connfd
2. 用户态/内核态copy数据。每个connfd对应着2个应用缓冲区：readbuf和writebuf。
3. 处理connfd发来的数据。业务逻辑处理，准备response到writebuf。



### Reactor模型

无论是C++还是Java编写的网络框架，大多数都是基于Reactor模型进行设计和开发，Reactor模型基于事件驱动，特别适合处理海量的I/O事件。

Reactor模型中定义的三种角色：

- **Reactor**：负责监听和分配事件，将I/O事件分派给对应的Handler。新的事件包含连接建立就绪、读就绪、写就绪等。
- **Acceptor**：处理客户端新连接，并分派请求到处理器链中。
- **Handler**：将自身与事件绑定，执行非阻塞读/写任务，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。可用资源池来管理。

