## MySQL性能优化



> "树根的数据块总是在内存中的"



##### 连接数查看

```sql
mysql> show processlist;
```

- Sleep表示空闲连接
- 客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制 的，默认值是 8 小时



##### 长连接

长连接可减少MySQL建立连接的操作，提升性能，但是存在一个问题：

- MySQL在执行过程中临时使用的内存是管理在连接对象里面的，这些资源会在连接断开的时候才释放，所以如果长连接累积使用下来，会导致内存占用增大
  - 解决：在MySQL5.7版本以后，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源，这个过程不需要重新连接和校验权限，但是会将连接重置到新创建时的状态



##### 禁用查询缓存

查询缓存失效频繁，只要对一个表进行更新，那么这个表上的所有查询缓存都会被清空，会加大数据库压力，除非你的表是一张静态表

好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语

```sql
mysql> select SQL_CACHE * from T where ID=10;
```

需要注意的是，**MySQL 8.0 版本直接将查询缓存的整块功能删掉**了，也就是说 8.0 开始彻底没 有这个功能了



##### 全表扫描

给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据



##### MDL

由于MDL的存在，会导致读写表和修改表结构直接发生阻塞，阻塞之后的所有客户端都将无法访问表，解决：**WAIT N**

```sql
ALTER TABLE tbl_name NOWAIT add column ... 
ALTER TABLE tbl_name WAIT N add column ...
```



##### 两阶段锁协议

如果你的事务中需要锁多个行，要把 最可能造成锁冲突、最可能影响并发度的锁尽量往后放



##### 死锁

方案：发起死锁检测：出现死锁，则失败其中一个事务，让另一个事务可以继续执行

缺点：死锁检测耗时时间，并发事务越多，检测耗时越长

缺点优化：怎么解决由这种热点行更新导致的性能问题呢?

- **控制并发度**：这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现;如果你的 团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。基本思路就是，对于相同行的更 新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。



##### 索引

普通索引和唯一索引应该怎么选择：

- 其实，这两类索引在查询能力上 是没差别的，主要考虑的是对更新性能的影响。所以，我建议你**尽量选择普通索引**
