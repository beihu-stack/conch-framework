## MySQL性能优化



> "树根的数据块总是在内存中的"



##### 连接数查看

```sql
mysql> show processlist;
```

- Sleep表示空闲连接
- 客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制 的，默认值是 8 小时



##### 长连接

长连接可减少MySQL建立连接的操作，提升性能，但是存在一个问题：

- MySQL在执行过程中临时使用的内存是管理在连接对象里面的，这些资源会在连接断开的时候才释放，所以如果长连接累积使用下来，会导致内存占用增大
  - 解决：在MySQL5.7版本以后，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源，这个过程不需要重新连接和校验权限，但是会将连接重置到新创建时的状态



##### 禁用查询缓存

查询缓存失效频繁，只要对一个表进行更新，那么这个表上的所有查询缓存都会被清空，会加大数据库压力，除非你的表是一张静态表

好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语

```sql
mysql> select SQL_CACHE * from T where ID=10;
```

需要注意的是，**MySQL 8.0 版本直接将查询缓存的整块功能删掉**了，也就是说 8.0 开始彻底没 有这个功能了



##### 全表扫描

给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据



##### MDL

由于MDL的存在，会导致读写表和修改表结构直接发生阻塞，阻塞之后的所有客户端都将无法访问表，解决：**WAIT N**

```sql
ALTER TABLE tbl_name NOWAIT add column ... 
ALTER TABLE tbl_name WAIT N add column ...
```



##### 两阶段锁协议

如果你的事务中需要锁多个行，要把 最可能造成锁冲突、最可能影响并发度的锁尽量往后放



##### 死锁

方案：发起死锁检测：出现死锁，则失败其中一个事务，让另一个事务可以继续执行

缺点：死锁检测耗时时间，并发事务越多，检测耗时越长

缺点优化：怎么解决由这种热点行更新导致的性能问题呢?

- **控制并发度**：这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现;如果你的 团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。基本思路就是，对于相同行的更 新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。



##### 索引

普通索引和唯一索引应该怎么选择：

- 其实，这两类索引在查询能力上 是没差别的，主要考虑的是对更新性能的影响。所以，我建议你**尽量选择普通索引**



##### 脏页

磁盘数据块与内存数据库不一致的情况，我们称为脏页

MySQL控制脏页刷盘更新：

- redo log 空间不够用
- 脏页比例大了
- 内存不够用

查询脏页比例情况：

```sql
select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';
select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total'; 
select @a/@b;
```

防止MySQL抖动：合理设置 innodb_io_capacity 的值（控制脏页刷盘），并且**平时要多关注脏页比 例，不要让它经常接近 75%**。

**蔓延策略**：在准备刷一个脏页的时候，如果这个数据页旁 边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉

在 InnoDB 中，**innodb_flush_neighbors** 参数就是用来控制这个行为的，值为 1 的时候会有上 述的“连坐”机制，值为 0 时表示不找邻居，自己刷自己的。

找“邻居”这个优化在机械硬盘时代是很有意义的，可以减少很多随机 IO。机械硬盘的随机 IOPS 一般只有几百，相同的逻辑操作减少随机 IO 就意味着系统性能的大幅度提升。

而如果使用的是 SSD 这类 IOPS 比较高的设备的话，我就建议你把 innodb_flush_neighbors 的值设置成 0。因为这时候 IOPS 往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷 脏页操作，减少 SQL 语句响应时间。

在 MySQL 8.0 中，innodb_flush_neighbors 参数的默认值已经是 0 了。
