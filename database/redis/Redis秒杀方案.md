## Redis秒杀方案

### 秒杀场景分析

数据库只能提供每秒千级别的并发，Redis能够提供每秒万甚至跟高的并发，所以需要使用Redis对部分流量进行拦截（库存查询校验拦截）

##### 秒杀前 - 不需要Redis

在这个阶段，用户会不断刷新商品详情页，这会导致详情页的瞬时请求量剧增。这个阶段的应对方案，一般是尽量把商品详情页的页面元素静态化，然后使用 CDN 或是浏览器把这些静态化的元素缓存起来。这样一来，秒杀前的大量请求可以直接由 CDN 或是浏览器缓存服务，不会到达服务器端了，这就减轻了服务器端的压力。



##### 秒杀活动开始

用户疯狂点击秒杀按钮，**校验商品库存**，如果库存校验通过，则进行库存扣减，订单处理；

查询商品库存：

- 这个阶段，最大的并发量在 查询商品库存上，所以我们可以 **将 商品的库存放入Redis**

执行库存扣减：

- 扣减库存如果放在数据库的话
  - 需要额外维护Redis的库存的更新
  - Redis库存校验通过后，需要在数据库层面进行二次库存的再校验，避免超卖的情况
- 鉴于以上问题，我们可以考虑将库存扣减的操作一起放入Redis这层，我们只需要保证redis的可靠性即可
  - **将库存校验和扣减放入一个原子操作中**

订单处理：

- 放到数据库层面，可能涉及物流等其他事务操作



##### 秒杀后

- 退单？



### Redis秒杀支持

数据结构选择：Hash

- Key： 秒杀批次 + 商品编号
- Value：{total: 100, ordered: 20}    ； total 总库存，ordered 已秒杀的数量



方案一：原子操作

- 使用Lua脚本原子操作

  ```shell
  # 获取商品库存信息
  local counts = redis.call("HMGET", KEY[1], "total", "ordered")
  local total = tonumber(counts[1])
  local ordered = tonumber(counts[2])
  
  # 如果当前请求库存量加上已秒杀的库存量 依旧小于等于 总库存量，则可以更新库存
  if ordered + k <= total then
  		# 更新已秒杀库存
  		redis.call("HINCRBY", KEY[1], "ordered", k)
  		return k;
  end
  return 0;
  ```

- 秒杀商品数据量大的话，可以使用Redis分片存储



方案二：使用分布式锁

- 我们可以使用切片集群中的不同实例来分别保存分布式锁和商品库存信息