## Redis分布式锁

分布式锁要求：

- 要求一：分布式锁的加锁和释放锁的过程，涉及多个操作。所以，在实现分布式锁时，我们需要保证这些锁操作的原子性；

- 要求二：共享存储系统保存了锁变量，如果共享存储系统发生故障或宕机，那么客户端也就无法进行锁操作了。在实现分布式锁时，我们需要考虑保证共享存储系统的可靠性，进而保证锁的可靠性。



##### 单Redis节点

- SETNX + DEL + EXPIRE + Lua脚本

  - 问题一：如果客户端获取锁后，因为业务异常，一直为调用DEL，则会导致锁阻塞

    - 解决：锁 增加 过期时间

  - 问题二：客户端A获取锁后，客户端B执行的DEL操作，导致A的锁被误释放

    - 解决：锁变量的值 具备 客户端唯一性

    - ```shell
      # 加锁 - Redis命令
      set lock_key unique_value NX PX 10000
      
      # 释放锁 - Lua脚本 判断 unique_value
      if redis.call("get", KEY[1]) == ARGV[1] then
      	 return redis.call("del", KEY[1])
      else
      	 return 0
      end
      
      # 执行Lua脚本
      redis-cli --eval unlock.script lock_ley,unique_value
      ```

  - 问题三：单Redis如果出现故障，则会影响业务



##### 多Redis节点

- Redlock红锁：大多数
  - 客户端依次与多个Redis实例请求加锁，当达到半数以上的实例加锁成功，则认为加锁成功
  - 实现：
    - 第一步是，客户端获取当前时间。
    - 第二步是，客户端按顺序依次向 N 个 Redis 实例执行加锁操作。
      - 这里的加锁操作和在单实例上执行的加锁操作一样，使用 SET 命令，带上 NX，EX/PX 选项，以及带上客户端的唯一标识。当然，如果某个 Redis 实例发生故障了，为了保证在这种情况下，Redlock 算法能够继续运行，我们需要给加锁操作设置一个超时时间。
      - 如果客户端在和一个 Redis 实例请求加锁时，一直到超时都没有成功，那么此时，客户端会和下一个 Redis 实例继续请求加锁。**加锁操作的超时时间需要远远地小于锁的有效时间，一般也就是设置为几十毫秒**。
    - 第三步是，一旦客户端完成了和所有 Redis 实例的加锁操作，客户端就要计算整个加锁过程的总耗时。
  - 加锁成功的条件：
    - **条件一：超过半数以上的Redis实例加锁成功**
    - **条件二：客户端获取锁的总耗时没有超过锁的有效时间**
  - 锁有效时间：
    - 满足加锁成功的条件后，需重新计算锁的有效时间，  **新有效时间 = 原始有效时间 - 加锁总耗时**
    - 如果 新有效时间 已经来不及完成共享数据操作了，我们可以释放锁，避免在操作过程中，锁失效了
  - 锁释放：
    - **如果没有满足锁成功的条件，则客户端需要操作向所有Redis节点发起释放锁操作**

